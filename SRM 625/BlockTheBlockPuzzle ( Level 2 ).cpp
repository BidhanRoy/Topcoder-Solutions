/*
 * Bidhan Roy
 * University of Dhaka
 */

using namespace std;
#include <bits/stdc++.h>

#define foreach(i,n) for(__typeof((n).begin())i =(n).begin();i!=(n).end();i++)
#define sgn(x,y) ((x)+eps<(y)?-1:((x)>eps+(y)?1:0))
#define rep(i,n) for(__typeof(n) i=0; i<(n); i++)
#define mem(x,val) memset((x),(val),sizeof(x));
#define rite(x) freopen(x,"w",stdout);
#define read(x) freopen(x,"r",stdin);
#define all(x) x.begin(),x.end()
#define sz(x) ((int)x.size())
#define sqr(x) ((x)*(x))
#define pb push_back
#define mp make_pair
#define clr clear()
#define inf (1<<27)
#define ins insert
#define xx first
#define yy second
#define eps 1e-9

typedef long long i64;
typedef unsigned long long ui64;
typedef string st;
typedef vector<int> vi;
typedef vector<st> vs;
typedef map<int,int> mii;
typedef map<st,int> msi;
typedef set<int> si;
typedef set<st> ss;
typedef pair<int,int> pii;
typedef vector<pii> vpii;

namespace dinic{

    #define MAXN 10000 ///total nodes
    #define MAXE 40000 ///4*total edges
    #define INF 1000000000 ///1LL<<55 incase of i64
    #define wint i64 ///int or i64?

    struct edge {
        int a, b;
        int cap;
        wint flow;
    };

    int n, s, t, ptr[MAXN], q[MAXN];
    int d[MAXN],esize;
    edge e[MAXE];
    vector<int> g[MAXN];

    void init(int _n,int _s,int _t){
        n=_n, s=_s, t=_t;
        esize=0;
        for(int i=0; i<n; i++) g[i].clear();
    }

    void add_edge(int a, int b, int cap) {
        edge e1 = { a, b, cap, 0 };
        edge e2 = { b, a, 0, 0 };
        g[a].push_back (esize);
        e[esize++]=e1;
        g[b].push_back (esize);
        e[esize++]=e2;
    }

    bool bfs() {
        int qh=0, qt=0;
        q[qt++] = s;
        memset (d, -1, n * sizeof d[0]);
        d[s] = 0;
        while (qh < qt && d[t] == -1) {
            int v = q[qh++];
            for (size_t i=0; i<g[v].size(); ++i) {
                int id = g[v][i], to = e[id].b;
                if (d[to] == -1 && e[id].flow < e[id].cap) {
                    q[qt++] = to;
                    d[to] = d[v] + 1;
                }
            }
        }
        return d[t] != -1;
    }

    wint dfs (int v, wint flow) {
        if (!flow)  return 0;
        if (v == t)  return flow;
        for (; ptr[v]<(int)g[v].size(); ++ptr[v]) {
            int id = g[v][ptr[v]],
                to = e[id].b;
            if (d[to] != d[v] + 1)  continue;
            wint pushed = dfs (to, min (flow, e[id].cap - e[id].flow));
            if (pushed) {
                e[id].flow += pushed;
                e[id^1].flow -= pushed;
                return pushed;
            }
        }
        return 0;
    }

    wint dinic() {
        wint flow = 0;
        while(true){
            if (!bfs())  break;
            memset (ptr, 0, n * sizeof ptr[0]);
            while (wint pushed = dfs (s, INF))
                flow += pushed;
        }
        if(flow>=inf) return -1;
        return flow;
    }
}

int dx[]={-1,+0,+1,+0};
int dy[]={+0,+1,+0,-1};

class BlockTheBlockPuzzle {
	#define pos(x,y) ((x)*n+(y))
public:
	int minimumHoles(vector <string> board) {
		int n = sz(board);
		int src = -1, snk = n*n*2;
		rep(i,n) rep(j,n) if(board[i][j]=='$') src = n*n+pos(i,j);
		dinic::init( snk+1, src, snk );
		rep(i,n) {
			rep(j,n) {
				if( board[i][j] == 'H' ) continue;
				dinic::add_edge( pos(i,j), n*n+pos(i,j), 1 );
				if( board[i][j] == 'b' ) dinic::add_edge ( pos(i,j) , snk , inf );
				rep( dir , 4 ) {
					
					int nx = i+dx[dir] , ny = j+dy[dir];
					int nx2 = i+dx[dir]*2 , ny2 = j+dy[dir]*2;
					int nx3 = i+dx[dir]*3 , ny3 = j+dy[dir]*3;
					
					if( !( 0 <= nx3 && nx3 < n ) ) continue;
					if( !( 0 <= ny3 && ny3 < n ) ) continue; 
					
					int cnt = bool(board[ nx ][ ny ] !='H') + bool(board[ nx2 ][ ny2 ] !='H') ;
					
					if( cnt>0 && ( board[ nx3 ][ ny3 ] !='H') )
						if( board[ nx2 ][ ny2 ] == 'b' || board[ nx ][ ny ] == 'b') cnt = inf; 
						dinic::add_edge( n*n+pos(i,j) ,  pos( nx3 , ny3 ) , cnt );
				}
			}
		}
		return dinic::dinic();
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	BlockTheBlockPuzzle *obj;
	int answer;
	obj = new BlockTheBlockPuzzle();
	clock_t startTime = clock();
	answer = obj->minimumHoles(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"b..$","....","HHHH","HHHH"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"............H..","...............","...............","HHH$HHH.....H..","HHHHHHH........","HHHHHHHH.......","......b..H.....","...............","...............","...H..H..H.....","...............","...............","...............","...............","..............."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"............H..","...............","...............","HHH$HHH........","HHHHHHH........","HHHHHHHH.......","......b..H.....","...............","...............","...H..H..H.....","...............","...............","...............","...............","..............."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"b..$...","...H...",".......","b..b..b","...H...",".......","b..b..b"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 4;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"b..b..b","..b..b.",".......","b..$bbb",".b.....","....b..","b..b..b"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = -1;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Block Puzzle is played on a square grid of unit cells. Some of those cells are marked as start cells, and one is marked as a goal cell.
// 
// The player begins by placing a 1x1x2 block on top of one of the start cells in such a way that the 1x1 face of the block coincides with the cell.
// The goal of the game is to reach the state where the block stands with its 1x1 face covering the goal cell.
// The game is played by rolling the block across the board.
// Only some types of moves are allowed:
// When the block stands on its 1x1 face, the player may roll the block in either of the four basic directions.
// However, when the block's bottom face is 2x1, the player may only roll it onto one of its 1x1 faces.
// In other words, the block must always be rolled over an edge of length 1.
// 
// All allowed moves are shown in the figure below. (The old state of the block is always semi-transparent, the new state is opaque.)
// 
// 
// 
// So far, the game seems trivial.
// Its difficulty comes from the fact that there are holes instead of some cells.
// Whenever the entire bottom face of the block stands on a hole, the block falls through the hole and the player loses the game. The block also falls off if the player rolls it across the edge of the game board.
// (Note that if the block stands on a 2x1 face and only one of the two cells under the face is missing, the block is still safe.
// Technically, the block would also be safe with one half of its bottom face sticking out of the game board, but obviously a move into such a configuration will never help you reach the goal.)
// 
// Bohn has been playing Block Puzzle too much. Jrus is bored, so he decided to make Bohn's game unsolvable by making more holes into his board.
// Jrus can only remove cells that are neither starting nor goal. As he doesn't want to get caught, he wants to remove as few cells as possible.
// 
// You are given the current board as a vector <string> board.
// The character '.' represents an ordinary cell, 'H' is a hole, 'b' is a starting cell, and '$' is the only goal cell.
// Return the smallest number of cells that have to be removed in order to make the puzzle unsolvable.
// If it is not possible to make the puzzle unsolvable, return -1 instead.
// 
// 
// 
// 
// 
// DEFINITION
// Class:BlockTheBlockPuzzle
// Method:minimumHoles
// Parameters:vector <string>
// Returns:int
// Method signature:int minimumHoles(vector <string> board)
// 
// 
// CONSTRAINTS
// -n will be between 3 and 50, inclusive.
// -board will contain exactly n elements.
// -Each element of board will contain exactly n characters.
// -Each character in board will be '.', 'H', 'b' or '$'.
// -board will contain exactly one '$' character.
// -board will contain at least one 'b' character.
// 
// 
// EXAMPLES
// 
// 0)
// {"b..$",
//  "....",
//  "HHHH",
//  "HHHH"}
// 
// Returns: 2
// 
// Remove the two cells between the start and the goal. Note that removing just one of them is not enough.
// 
// 1)
// {"............H..",
//  "...............",
//  "...............",
//  "HHH$HHH.....H..",
//  "HHHHHHH........",
//  "HHHHHHHH.......",
//  "......b..H.....",
//  "...............",
//  "...............",
//  "...H..H..H.....",
//  "...............",
//  "...............",
//  "...............",
//  "...............",
//  "..............."}
// 
// Returns: 0
// 
// This puzzle is already unsolvable.
// 
// 2)
// {"............H..",
//  "...............",
//  "...............",
//  "HHH$HHH........",
//  "HHHHHHH........",
//  "HHHHHHHH.......",
//  "......b..H.....",
//  "...............",
//  "...............",
//  "...H..H..H.....",
//  "...............",
//  "...............",
//  "...............",
//  "...............",
//  "..............."}
// 
// Returns: 1
// 
// This puzzle is solvable. The only difference between this puzzle and Example 1 is that one cell in this example was a hole in Example 1. Hence, we can easily make this puzzle unsolvable by removing that one cell.
// 
// 3)
// {"b..$...",
//  "...H...",
//  ".......",
//  "b..b..b",
//  "...H...",
//  ".......",
//  "b..b..b"}
// 
// 
// 
// Returns: 4
// 
// A puzzle may contain multiple starting cells. Bohn may start the game from any of them.
// 
// 4)
// {"b..b..b",
//  "..b..b.",
//  ".......",
//  "b..$bbb",
//  ".b.....",
//  "....b..",
//  "b..b..b"}
// 
// 
// Returns: -1
// 
// You cannot replace start cells with holes.
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
